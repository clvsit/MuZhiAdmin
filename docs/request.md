# 请求内容说明
【流程说明】：

- 员工成功登录到后台管理系统后，系统需要根据员工工号和当前系统时间生成 token，并将 token 返回给前端。
- 此后，前端的所有请求都带有 token，系统需要验证 token 是否正确。判断方式请参考后续的**token 验证机制**。

## token 验证机制
【token 格式】：
```
员工工号（13 位） + 当前系统时间（YYMMdd，6 位）
1547471774769 190115
```
【注意】：1547471774769 和 190115 之间没有空格，空格是为了方便阅读。

token 拼接完成后，需要对 token 进行 base64 编码。

【最终格式】：
```
MTU0NzQ3MTc3NDc2OTE5MDExNQ==
```

#### 设计思路
整体设计思路可分为两部分，其一是为了后续操作的便捷，其二是确保数据传递的安全性。

【便捷性考虑】：员工的许多操作都需要记录在数据表中，例如员工修改了植物分类信息。记录格式为“谁 + 时间 + 做了什么”，因此需要前端提供当前操作员工的工号。既然员工工号在大多数的接口中都有涉及，那么就拿来作为 token 识别的一部分。

- 除了上述原因外，作为 token 的参数必须是保存在数据库中的数据，要不然无法进行比对，总不能系统生成一个 token 就保存到内存中吧。
- 使用员工工号，而非员工账号也能够在一定程度上保护员工账号信息，且员工账号通过 md5 加密后是不能再转回来处理，因此前后端要通过员工账号来进行信息交互，要么再进行一层加密，要么就直接用 md5 形式的员工账号进行交互，这非常不安全。

【安全性考虑】：单独以员工工号作为 token 还是存在一定的风险，因此再加上当前系统的指定格式以增加 token 的长度与复杂度。

#### 验证过程
员工登录成功后，系统返回 token，例如：
```
MTU0NzQ3MTc3NDc2OTE5MDExNQ==
```

此后，前端的每次请求都会带有反转的 token，例如：
```
=QNxEDM5ETO2cDN3cTM3QzN0UTM
```

系统接收到反转的 token 后，需要先进行转置操作，还原成标准格式的 token，然后再进行 base64 解码。
```
1547471774769190115
```

将得到的解码结果进行切分，前 13 位为员工工号，后 6 位为当前系统时间（生成 token 的系统时间，后续说明以 **token 时间**代替）。

- 判断员工工号是否存在。
- 判断 token 时间是否与当前系统日期吻合。